#ifndef ADJOBJGEN_CPP
#define ADJOBJGEN_CPP

#include "AdjacencyObjectsGenerator.hpp"

AdjacencyObjectsGenerator::AdjacencyObjectsGenerator(
  const int _adjency_matrix_dim,
  const int _char_dim,
  const int _metric_dim)
{
  overall_adjency_matrix_dimension = (_adjency_matrix_dim > 1) ? _adjency_matrix_dim : 2;
  characters_dimension = (_char_dim > 0) ? _char_dim : 3;
  metric_dimension = (_metric_dim > 0) && (_metric_dim < 10) ? _metric_dim : 5;
}

graphPayload AdjacencyObjectsGenerator::generate_data()
{
  //generate random metrics
  auto generate_metric = [&]()
  {
    //data, where from get characters to generate quazi random metric
    std::string metrics_chars("1234567890");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, static_cast<unsigned int>(metrics_chars.size() - 1));
    std::string _buf;

    //more than 8 length may cause an errors of memory scores that are generated by types like int/long long
    for (unsigned int i = 0; i < metric_dimension; ++i) { _buf += metrics_chars[index_dist(rng)]; }

    //string literals to integer scalars
    const int int_metric = std::stoi(_buf);

    return int_metric;
  };

  //generate random names
  auto generate_names = [&]()
  {
    //data, where from get characters to generate quazi random metric
    std::string names_chars("ABCDEFGHGKLMNOPQRSTUZWY");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, static_cast<unsigned int>(names_chars.size() - 1));
    std::string _buf;

    for (unsigned int i = 0; i < characters_dimension; ++i) { _buf += names_chars[index_dist(rng)]; }

    return _buf;
  };

  //create vector to store names of servers
  std::vector <std::string> servers_names;

  /*---------------------------ADD SERVERS START-----------------------------*/
  for (unsigned int n = 0; n < overall_adjency_matrix_dimension; n++)
  {
    servers_names.emplace_back(generate_names()); //push random name
  }

  //pair them up
  std::vector < std::pair <std::string, std::string> > ps;

  bool _check = false;

  for (const auto &it_i : servers_names)
  {
    std::pair <std::string, std::string> _generated_nodes;
    for (const auto &it_j : servers_names)
    {
        if (it_i != it_j) //check if pair no in vector
        {

            std::pair <std::string, std::string> _temp = std::make_pair(it_i, it_j);

            _check = false;
            for (auto it = ps.cbegin(); it != ps.cend(); it++)
            {
                if (it->first == _temp.first && it->second == _temp.second ||
                    it->first == _temp.second && it->second == _temp.first)
                {
                    _check = true;
                    break;
                }
            }

            if (!_check)
                ps.emplace_back(_temp);

        }
    }
  }

  /*-----------------------------ADD SERVERS END------------------------------*/

  /*--------------------GENERATE KEY FOR EACH NODE/PAIR START------------------*/

  graphPayload servers_data;
  for (const auto &s_node : ps)
  {
    servers_data[generate_metric()].emplace_back(s_node);
  }

  /*--------------------GENERATE KEY FOR EACH NODE/PAIR END----------------------*/

  return servers_data;
}

graphPayload AdjacencyObjectsGenerator::get_adjency_objects()
{
  return generate_data();
}

#endif //ADJOBJGEN_CPP
