#ifndef ADJOBJGEN_CPP
#define ADJOBJGEN_CPP

#include "../include/AdjacencyObjectsGenerator.h"

AdjacencyObjectsGenerator::AdjacencyObjectsGenerator(
  int _adjency_matrix_dim,
  int _char_dim,
  int _metric_dim)
{

  this->overall_adjency_matrix_dimension = (_adjency_matrix_dim > 1) ? _adjency_matrix_dim : 2;
  this->characters_dimension = (_char_dim > 0) ? _char_dim : 3;
  this->metric_dimension = (_metric_dim > 0) && (_metric_dim < 10) ? _metric_dim : 5;

}

std::map <int, std::vector < std::pair <std::string, std::string> >>
AdjacencyObjectsGenerator::generate_data()
{

  //lambda to generate random metrics
  auto generate_metric = [&]()
  {

    //data, where from get characters to generate quazi random metric
    std::string metrics_chars("1234567890");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, metrics_chars.size() - 1);
    std::string _buf;

    //more than 8 length may cause an errors of memory scores that are generated by types like int/long long
    for (unsigned int i = 0; i < metric_dimension; ++i) { _buf += metrics_chars[index_dist(rng)]; }

    //string literals to integer scalars
    int int_metric = std::stoi(_buf);

    return int_metric;
  };

  //lambda to generate random Names
  auto generate_names = [&]()
  {

    //data, where from get characters to generate quazi random metric
    std::string names_chars("ABCDEFGHGKLMNOPQRSTUZWY");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, names_chars.size() - 1);
    std::string _buf;

    for (unsigned int i = 0; i < characters_dimension; ++i) { _buf += names_chars[index_dist(rng)]; }

    return _buf;
  };

  //create vector to store names of servers
  std::vector <std::string> servers_names;


  /*--------------------------------ADD SERVERS START------------------------------*/

  for (unsigned int n = 0; n < this->overall_adjency_matrix_dimension; n++)
  {
    servers_names.push_back(generate_names()); //push random name
  }


  //pair them up
  std::vector < std::pair <std::string, std::string> > ps;

  std::cout << "---Adjacency table:\n" << "\n";

  //generate adjacency table
  //if i == j (node A and node B are connected)

  //TODO
  //generate only unique adjacency pairs

  for (auto &it_i : servers_names)
  {

    std::pair <std::string, std::string> _generated_nodes;

    for (auto &it_j : servers_names)
    {

      if (it_i != it_j)
      {

        int rand_num = std::rand() % 2; //[0 - A & B are not connected; 1 - A & B are connected]
        std::cout << it_i << ": " << it_j << " = " << rand_num << "\n";

        if (rand_num == 1)
        {
          _generated_nodes = std::make_pair(it_i, it_j);
          ps.push_back(_generated_nodes);
        }

      }

    }

  }

  /*--------------------------------ADD SERVERS END------------------------------*/


  // display the results - debug info
  std::cout << "\n---Servers nodes:\n\n" << ps << "\n";


  /*-------------------GENERATE KEY FOR EACH NODE/PAIR START----------------------*/

  std::pair <std::string, std::string>  servers_pair;
  std::map < int, std::vector < std::pair <std::string, std::string> > > servers_data;

  std::cout << "---Count of server pairs/nodes is: " << ps.size() << "\n";
  for (auto &s_node : ps)
  {
    std::cout << s_node.first << " " << s_node.second << "\n";

    servers_data[generate_metric()].push_back(s_node);
  }

  /*--------------------GENERATE KEY FOR EACH NODE/PAIR END----------------------*/


  return servers_data;
}


std::map <int, std::vector < std::pair <std::string, std::string> >>
AdjacencyObjectsGenerator::get_adjency_objects()
{
  std::lock_guard <std::mutex> guard(mtx);
  return generate_data();
}

#endif