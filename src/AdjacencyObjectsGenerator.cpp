#ifndef ADJOBJGEN_CPP
#define ADJOBJGEN_CPP

#include "../include/AdjacencyObjectsGenerator.h"

AdjacencyObjectsGenerator::AdjacencyObjectsGenerator(
  const int _adjency_matrix_dim,
  const int _char_dim,
  const int _metric_dim)
{
  this->overall_adjency_matrix_dimension = (_adjency_matrix_dim > 1) ? _adjency_matrix_dim : 2;
  this->characters_dimension = (_char_dim > 0) ? _char_dim : 3;
  this->metric_dimension = (_metric_dim > 0) && (_metric_dim < 10) ? _metric_dim : 5;
}

graphPayload AdjacencyObjectsGenerator::generate_data()
{

  //lambda to generate random metrics
  auto generate_metric = [&]()
  {

    //data, where from get characters to generate quazi random metric
    std::string metrics_chars("1234567890");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, static_cast<unsigned int>(metrics_chars.size() - 1));
    std::string _buf;

    //more than 8 length may cause an errors of memory scores that are generated by types like int/long long
    for (unsigned int i = 0; i < metric_dimension; ++i) { _buf += metrics_chars[index_dist(rng)]; }

    //string literals to integer scalars
    int int_metric = std::stoi(_buf);

    return int_metric;
  };

  //lambda to generate random Names
  auto generate_names = [&]()
  {

    //data, where from get characters to generate quazi random metric
    std::string names_chars("ABCDEFGHGKLMNOPQRSTUZWY");
    std::random_device rng;

    std::uniform_int_distribution<> index_dist(0, static_cast<unsigned int>(names_chars.size() - 1));
    std::string _buf;

    for (unsigned int i = 0; i < characters_dimension; ++i) { _buf += names_chars[index_dist(rng)]; }

    return _buf;
  };

  //create vector to store names of servers
  std::vector <std::string> servers_names;

  /*--------------------------------ADD SERVERS START------------------------------*/

  for (unsigned int n = 0; n < this->overall_adjency_matrix_dimension; n++)
  {
    servers_names.push_back(generate_names()); //push random name
  }

  //pair them up
  std::vector < std::pair <std::string, std::string> > ps;

  //generate adjacency table
  //if i == j (node A and node B are connected)
  for (auto &it_i : servers_names)
  {

    std::pair <std::string, std::string> _generated_nodes;

    for (auto &it_j : servers_names)
    {

      if (it_i != it_j)
      {

        int rand_num = std::rand() % 2; //[0 - A & B are not connected; 1 - A & B are connected]
        std::cout << it_i << ": " << it_j << " = " << rand_num << "\n";

        if (rand_num == 1)
        {
          _generated_nodes = std::make_pair(it_i, it_j);
          ps.push_back(_generated_nodes);
        }

      }

    }

  }

  /*--------------------------------ADD SERVERS END------------------------------*/

  //create set
  std::set <std::pair <std::string, std::string>> unique_set;

  //get vector size fof adjacency nodes pairs
  size_t size = ps.size();

  //add elements of nodes to new set
  for (unsigned i = 0; i < size; ++i) unique_set.insert(ps[i]);

  //replace elements with unique nodes to vector
  ps.assign(unique_set.begin(), unique_set.end());

  /*-------------------GENERATE KEY FOR EACH NODE/PAIR START----------------------*/

  std::pair <std::string, std::string>  servers_pair;
  graphPayload servers_data;

  for (auto &s_node : ps)
  {
    servers_data[generate_metric()].push_back(s_node);
  }

  /*--------------------GENERATE KEY FOR EACH NODE/PAIR END----------------------*/


  return servers_data;
}


graphPayload AdjacencyObjectsGenerator::get_adjency_objects()
{
  return generate_data();
}

#endif